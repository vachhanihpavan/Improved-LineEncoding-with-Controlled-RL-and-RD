# Design

## Encoding Algorithm

In order to encode the bit stream we use two algorithms. First we apply RL handling algorithm and then apply RD handling parallelly.

**Combining RL and RD algorithms**

If both the RD and RL bounds should be controlled simultaneously, a simple serial application of the bit stuffing and the S-bit inversion techniques does not work even in any order.

In order to reduce the high RL handling overhead, we propose a combined RL-RD handling approach. The main idea is to use APPLY_RL_HANDLING (x) procedure whenever bits are output by the S-bit inversion technique.

**Idea of Algorithm**
* Procedure UPDATE_RD() updates the RD value of the bit sequence sent so far, and a global variable RD contains its value, like UPDATE_RL(x).

* Procedure PREPARE_S_BLOCK (RD_FIFO ) sets a flag S flag for the S-bit inversion technique. That is, if it is '1', the S-block is inverted with the indication bit insertion of '1' at the end, if it is '-1', the S-block is untouched with the indication bit insertion of '0', and finally, if it is '0', the S-block is untouched with no indication bit insertion.

* When exiting the S-block, the RD may be again equal to RD_TH. In this case, the S-block handling is immediately restarted.

* When exiting the S-block, the RD value is checked, and if it absolute value exceeds RD TH, '1' or '0' is inserted several times until the RD value becomes equal to RD TH. We call it S-block RD-adjustment.

## Decoding Algorithm

In order to decode the bit stream received at the receiver side, the stuffed bits should be removed first. We apply procedure to decode RL part first. Then extra bits of RL and RD are removed together.

**Decoding RL procedure**

This function is written as DECODE_RL which removes bit stuffings of RL only. It is exact reverse of APPLY_RL_HANDLING. This doesn't remove bits which are added as RL bits but while in S-block as a part of RD handling.

**Combined Decoding**
In DECODE_COMBINED procedure, the bit obtained by DECODE_RL procedure is just sent out to the receiver body. If RD reaches RD_TH, the procedure goes inside S block mode with initializing the FIFO. In this mode, the given bits are just put into the FIFO. The final bit of the S-block is processed in 'process indication bit' mode. Then FIFO bits are processed according to the indication bit inserted by INSERT_INDICATION_BIT function while encoding.

## Code Organization and Control Flow

**Control Flow**

1. String to Binary Conversion
2. Encoding Algorithm
3. Decoding Algorithm
4. Binary to String Algorithm
5. MATLAB code to plot graphs

**Code Organization**

1. String to Binary Conversion - *s2b.cpp*
    * This C++ code takes string as input which is converted into binary form.
    * Each character of the string is converted to its respective 8-bit ASCII binary byte using *\<bitset\>*.
    * These bytes of data are written to a file generated by file stream and named *input_binary.txt*.


2. Encoding Algorithm - *encode.cpp*
    * This part takes the file generated by previous program as input along with MAX_RL, RD_TH and S-block size as inputs.
    * Then it encodes the data using the algorithm provided in the reference paper. It adds RL and RD bounds to the data stream.
    * This encoded stream is written to a file *encoded_data.txt*.
    * It also prints the amount of bits stuffed and precentage line overhead.

3. Decoding Algorithm - *decode.cpp*
    * Here encoded data is received and decoded to obtain the original data. Here MAX_RL, RD_TH and S-block size are inputs.
    * Decoded bit stream is written to file named *decoded_data.txt*.

4. Binary to String Algorithm
    * This code converts the bits stream to character string and prints it.
    * It uses *std::istringstream* and *to_ulong* to take eight bits and convert to corresponding characters.

5. MATLAB code to plot graphs
    * It plots the binary data of decode and encode in 2 different subplots in same figure to compare real time stream.

## Execution Flow

1. The Flow of execution is the order in which the files must be executed to perform the implementation of the encoding decoding process.
2. First the string should be converted to binary so we use the simple C++ program to convert the input string in the terminal to binary set and perform the encoding operation.
3. Now the encoding file. This file is executed second that is after the conversion of string to binary and performs the operations based on the input RL and RD values.
4. Now after the binary string is transferred we need to deode the binary string. For this we use the decode.cpp which then decodes the string into normal binary fromat from the previous implementation.
5. Later for the messge to be delivered to the reciever we need to convert the binary back to string so we use another conversion technique and convert it back to understandable english characters.
So the above steps are followed during the execution flow and missing file may cause the termination of the program.
For users to make it simple, so that they can use it with one click, we have added an integrator file which then combines all these files without the need of the user themselves
to run each program.

The Order of execution is explained here:
    system("s2b.exe");
    system("encode.exe");
    system("decode.exe");
    system("b2s.exe");

## Functions

1. MAX_RL function is the maximum running lenght of the input bit stream that is beign entered in the form of a string. RL is the number of same bits in the bitstream.
2. RD_TH function is for the operation of running disparity in the bitstream.
3. S block function or gennerally s block is the previous line coding scheme over which this development hs been made and overhead has been decreased.
